using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Threading;

namespace GeneratorFromAttribute;

[Generator(LanguageNames.CSharp)]
public sealed class GeneratorsFromAttributeClass : IIncrementalGenerator
{
    private static readonly string generatedCodeAttribute = $@"[global::System.CodeDom.Compiler.GeneratedCodeAttribute(""{typeof(GeneratorsFromAttributeClass).Assembly.GetName().Name}"", ""{typeof(GeneratorsFromAttributeClass).Assembly.GetName().Version}"")]";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(GenerateFixedClasses);

        IncrementalValuesProvider<(string TypeName, Accessibility ClassAccessibility, string? Namespaces, MasterType masterType)> provider =
            context.SyntaxProvider.ForAttributeWithMetadataName(
                "GeneratorsFromAttributeExample.GenerateSetPropertyAttribute`1",
                predicate: FilterClass,
                transform: CreateObjCollection);

        var collectedClasses = provider.Collect();
        context.RegisterSourceOutput(collectedClasses, CreateSourceCode!);
    }

    private static void GenerateFixedClasses(IncrementalGeneratorPostInitializationContext context)
    {
        //language=c#
        var source = $$"""
            // <auto-generated/>
            #nullable enable
            using System;

            namespace GeneratorsFromAttributeExample;

            {{generatedCodeAttribute}}
            [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = false)]
            internal sealed class GenerateSetPropertyAttribute<T>() : Attribute where T : class
            {}
            """;

        var fileName = "GeneratorFromAttributeExample.GenerateSetPropertyAttribute.g.cs";
        context.AddSource(fileName, source);
    }


    private static bool FilterClass(SyntaxNode node, CancellationToken cancellationToken) =>
        node is ClassDeclarationSyntax;

    private static (string TypeName, Accessibility ClassAccessibility, string? Namespaces, MasterType masterType) CreateObjCollection(GeneratorAttributeSyntaxContext context, CancellationToken _)
    {
        var symbol = (INamedTypeSymbol)context.TargetSymbol;
        var className = symbol.Name;

        var classDeclarationSyntax = (ClassDeclarationSyntax)context.TargetNode;
        var isPartial = classDeclarationSyntax.Modifiers.Any(SyntaxKind.PartialKeyword);
        var isStatic = classDeclarationSyntax.Modifiers.Any(SyntaxKind.StaticKeyword);

        var namespacesClass = string.IsNullOrEmpty(symbol.ContainingNamespace.Name) ? null : symbol.ContainingNamespace.ToDisplayString();
        MasterType masterType = new(className, isPartial, isStatic);
        List<string> classNames = [];

        foreach (var attributeData in context.Attributes)
        {
            var attributeType = attributeData.AttributeClass!;
            var typeArguments = attributeType.TypeArguments;
            var typeSymbol = typeArguments[0];
            if (classNames.Contains(typeSymbol.Name)) continue;
            classNames.Add(typeSymbol.Name);

            var ns = string.IsNullOrEmpty(typeSymbol.ContainingNamespace.Name) ? null : typeSymbol.ContainingNamespace.ToDisplayString();
            var properties = typeSymbol.GetMembers()
                .OfType<IPropertySymbol>()
                .Select(t => new SubProperty(t.Name, t.Type)).ToList();

            masterType.SubTypes.Add(new SubTypeClass(
                typeSymbol.Name,
                ns,
                properties)
            );
        }

        return (className, symbol.DeclaredAccessibility, namespacesClass, masterType);
    }

    private static void CreateSourceCode(SourceProductionContext ctx, ImmutableArray<(string TypeName, Accessibility ClassAccessibility, string Namespaces, MasterType MasterType)> collectedClasses)
    {
        foreach (var info in collectedClasses)
        {
            if (!info.MasterType.IsPartial || !info.MasterType.IsStatic)
            {
                Helper.ReportClassNotSupportedDiagnostic(ctx, info.MasterType.ClassName);
                continue;
            }

            using StringWriter writer = new(CultureInfo.InvariantCulture);
            using IndentedTextWriter tx = new(writer);

            tx.WriteLine("// <auto-generated/>");
            tx.WriteLine("#nullable enable");
            tx.WriteLine();
            tx.WriteLine("using GeneratorsFromAttributeExample;");

            if (!string.IsNullOrEmpty(info.Namespaces))
            {
                tx.WriteLine($"namespace {info.Namespaces}");
                tx.WriteLine('{');
                tx.Indent++;
            }

            tx.WriteLine($"[global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"{typeof(GeneratorsFromAttributeClass).Assembly.GetName().Name}\", \"{typeof(GeneratorsFromAttributeClass).Assembly.GetName().Version}\")]");
            tx.WriteLine($"{SyntaxFacts.GetText(info.ClassAccessibility)} static partial class {info.TypeName}");
            tx.WriteLine('{');
            tx.Indent++;

            foreach (var subType in info.MasterType.SubTypes)
            {
                var ns = string.IsNullOrEmpty(subType.Namespace) ? string.Empty : subType.Namespace! + ".";
                tx.WriteLine($"{SyntaxFacts.GetText(info.ClassAccessibility)} static void SetProperties{subType.Classname}({ns}{subType.Classname} obj, ReadOnlySpan<char> row)");
                tx.WriteLine('{');
                tx.Indent++;
                InsertPropertiesInSwitch(ctx, tx, subType);
                tx.Indent--;
                tx.WriteLine('}');
                tx.WriteLine();
            }

            tx.Indent--;
            tx.WriteLine('}');
            if (!string.IsNullOrEmpty(info.Namespaces))
            {
                tx.Indent--;
                tx.WriteLine('}');
            }

            Debug.Assert(tx.Indent == 0);
            ctx.AddSource($"GeneratorFromAttributeExample.{info.TypeName}.g.cs", writer.ToString());
        }
    }

    private static void InsertPropertiesInSwitch(SourceProductionContext context, IndentedTextWriter tx, SubTypeClass subType)
    {
        tx.WriteLine("var index = row.IndexOf(',');");

        for (var counter = 0; counter < subType.Properties.Count; counter++)
        {
            var property = subType.Properties[counter];
            var members = property.Type.GetMembers();

            var hasParseMethod = members.Any(m =>
                m.Name == "Parse" &&
                m is IMethodSymbol method &&
                method.IsStatic &&
                method.Parameters.Length >= 1 &&
                method.Parameters[0].Type.SpecialType == SpecialType.System_String);

            var isLastProperty = counter == subType.Properties.Count - 1;
            var sliceString = isLastProperty ? "row" : "row.Slice(0, index)";

            tx.WriteLine(hasParseMethod
                ? $"obj.{property.Name} = {property.Type.ToDisplayString()}.Parse({sliceString});"
                : $"obj.{property.Name} = {sliceString}.ToString();"
            );

            if (!isLastProperty)
            {
                tx.WriteLine("row = row.Slice(index + 1);");
                tx.WriteLine("index = row.IndexOf(',');");
            }
        }
    }
}